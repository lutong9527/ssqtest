from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from pydantic import BaseModel
from datetime import timedelta
from passlib.context import CryptContext
from sqlalchemy.exc import IntegrityError
from models.user import User
from database import get_db
from auth import verify_password, create_access_token, ACCESS_TOKEN_EXPIRE_MINUTES, get_current_user

# 密码哈希工具（全局使用 bcrypt）
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

router = APIRouter(
    prefix="",          # 前缀已在 main.py 统一设置为 /api/v1/auth
    tags=["认证"]
)


@router.post("/login")
def login_for_access_token(
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: Session = Depends(get_db)
):
    """
    用户登录，获取 JWT token
    """
    user = db.query(User).filter(User.username == form_data.username).first()
    if not user or not verify_password(form_data.password, user.password_hash):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="用户名或密码错误",
            headers={"WWW-Authenticate": "Bearer"},
        )

    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username}, expires_delta=access_token_expires
    )

    return {
        "access_token": access_token,
        "token_type": "bearer"
    }


@router.get("/me")
def read_users_me(current_user: User = Depends(get_current_user)):
    """
    获取当前登录用户信息（需要携带有效的 Bearer Token）
    """
    return {
        "id": current_user.id,
        "username": current_user.username,
        "role": current_user.role,
        "membership_level": current_user.membership_level,
        "email": current_user.email,
        "phone": current_user.phone
    }


# 用户注册接口
class RegisterRequest(BaseModel):
    username: str
    password: str
    email: str | None = None
    phone: str | None = None


@router.post("/register")
def register(
    request: RegisterRequest,
    db: Session = Depends(get_db)
):
    # 自动截断密码（防止超过 72 字节）
    password = request.password[:72]  # 安全截断（前 72 字符）

    # 检查用户名...
    existing_user = db.query(User).filter(User.username == request.username).first()
    if existing_user:
        raise HTTPException(status_code=400, detail="用户名已存在")

    # 创建用户
    hashed_password = pwd_context.hash(password)  # 使用截断后的密码哈希
    new_user = User(
        username=request.username,
        password_hash=hashed_password,
        email=request.email,
        phone=request.phone,
        role="visitor",
        membership_level="basic"
    )

    try:
        db.add(new_user)
        db.commit()
        db.refresh(new_user)
    except IntegrityError:
        db.rollback()
        raise HTTPException(status_code=400, detail="注册失败，可能用户名或邮箱重复")

    return {
        "message": "注册成功",
        "user": {
            "id": new_user.id,
            "username": new_user.username,
            "role": new_user.role
        }
    }

    # 检查邮箱是否已存在（如果提供了邮箱）
    if request.email:
        existing_email = db.query(User).filter(User.email == request.email).first()
        if existing_email:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="邮箱已注册"
            )

    # 截取密码，确保其长度不超过 72 字节
    password = request.password[:72]
    hashed_password = pwd_context.hash(password)  # 使用 bcrypt 生成哈希

    # 创建新用户
    new_user = User(
        username=request.username,
        password_hash=hashed_password,  # 存储哈希后的密码
        email=request.email,
        phone=request.phone,
        role="visitor",                  # 默认普通用户
        membership_level="basic"        # 默认基础会员
    )

    try:
        db.add(new_user)
        db.commit()
        db.refresh(new_user)
    except IntegrityError:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="注册失败，可能用户名或邮箱重复"
        )

    return {
        "message": "注册成功",
        "user": {
            "id": new_user.id,
            "username": new_user.username,
            "role": new_user.role
        }
    }
